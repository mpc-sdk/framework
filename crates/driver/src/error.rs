use thiserror::Error;

/// Errors generated by the driver.
#[derive(Debug, Error)]
pub enum Error {
    /// Error when the session identifier for an incoming message
    /// does not match the session identifier assigned to the bridge.
    #[error("session identifier mismatch for incoming message")]
    SessionIdMismatch,

    /// Error generated when a session identifier is required.
    #[error("session identifier required")]
    SessionIdRequired,

    /// Signing key does not exist in list of verifying keys.
    #[error("signer is not a verifying party")]
    NotVerifyingParty,

    /// Error when noise protocol participants list does not match
    /// the number of verifying keys.
    #[error("number of participants '{0}' does not match number of verifying keys '{1}'")]
    ParticipantVerifierLength(usize, usize),

    /// JSON error.
    #[error(transparent)]
    Json(#[from] serde_json::Error),

    /// CGGMP driver errors.
    #[cfg(feature = "cggmp")]
    #[error(transparent)]
    Cggmp(#[from] crate::cggmp::Error),

    /// FROST driver errors.
    #[cfg(feature = "frost-ed25519")]
    #[error(transparent)]
    Frost(#[from] crate::frost::Error),

    /// Protocol library errors.
    #[error(transparent)]
    Protocol(#[from] polysig_protocol::Error),

    /// ECDSA library errors.
    #[cfg(any(
        feature = "cggmp",
        feature = "ecdsa",
        feature = "schnorr"
    ))]
    #[error(transparent)]
    Ecdsa(#[from] k256::ecdsa::Error),

    /// Ed25519 library errors.
    // NOTE: must be boxed otherwise thiserror will compile two
    // NOTE: From implementations when the full feature is enabled
    #[cfg(any(feature = "eddsa", feature = "frost-ed25519"))]
    #[error(transparent)]
    Ed25519(#[from] Box<ed25519::Error>),
}

#[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
impl From<Error> for wasm_bindgen::JsValue {
    fn from(value: Error) -> Self {
        let s = value.to_string();
        wasm_bindgen::JsValue::from_str(&s)
    }
}
